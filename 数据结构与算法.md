# 数据结构与算法

## 数据结构

### 一,数据结构概论

#### 1).数据结构的研究内容

1. 计算机解题的步骤:![image-20220814165309195](https://raw.githubusercontent.com/LYSZ241/MyNotes/master/img/202210010107389.png)![image-20220814165414298](image-20220814165414298.png)
2. x 1int maxCount = 0,minWindow = 0;2HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();3for(int i = 0;i < nums.length;i++){4    int[] arr = map.get(nums[i]);5    if(arr == null){6        //new int[]{i,1}:i记录第几位,负责解决最小距离,1是数量7        arr = new int[]{i,1};8        map.put(nums[i],arr);9    }else{10        arr[1]++;11    }12​13    if(maxCount < arr[1]){14        maxCount = arr[1];15        minWindow = i - arr[0] + 1;16    }else if(maxCount == arr[1]){17        minWindow = Math.min(i - arr[0] + 1,minWindow);18    }19}20return minWindow;java

#### 2).数据的基本概念和术语

1. 数据:![image-20220814180751760](image-20220814180751760.png)
2. 数据元素:![image-20220814180919371](image-20220814180919371.png)
3. 数据项:![image-20220814181015275](image-20220814181015275.png)
4. 数据对象:![image-20220814181117093](image-20220814181117093.png)

5. 数据元素和数据对象:![image-20220814181423405](image-20220814181423405.png)

### 二,数据结构的内容:

#### 1).数据结构的种类

1. 数据结构的三个方面:

+ 数据元素的逻辑关系
+ 数据元素及其关系在计算机内存中的标识的存储结构,物理结构
+ 对数据元素可以施加的操作的存储结构上的实现![image-20220814220119087](image-20220814220119087.png)

2. 数据结构的两个层次:

   ![image-20220814220242747](image-20220814220242747.png)

3. 逻辑结构的种类(根据线性非线性划分):

   ![image-20220814220517185](image-20220814220517185.png)

4. 逻辑结构的种类(根据线性非线性划分):![image-20220814220709039](image-20220814220709039.png)

5. 存储结构(四大基本):
   + 顺序存储结构:![image-20220814221149350](image-20220814221149350.png)
   + 链式存储结构:![image-20220814221313547](image-20220814221313547.png)
   + 索引存储结构:![image-20220814221424927](image-20220814221424927.png)
   + 散列存储结构:![image-20220814221454205](image-20220814221454205.png)

### 三,数据类型和抽象类型

#### 1).数据类型:

1. 引用:![image-20220814221811986](image-20220814221811986.png)![image-20220814223102197](image-20220814223102197.png)

2. 数据类型的定义:![image-20220814223134143](image-20220814223134143.png)

3. 抽象数据类型的定义:![image-20220814223419712](image-20220814223419712.png)![image-20220814223531761](image-20220814223531761.png)

4. 基本操作:![image-20220814223713703](image-20220814223713703.png)![image-20220814230220381](image-20220814230220381.png)

#### 2).数据结构概念的总结:![image-20220815155250125](image-20220815155250125.png)

#### 3).抽象数据类型:

1. 抽象数据类型的实现:![image-20220815155459719](image-20220815155459719.png)

### 四,线性结构:

#### 1).线性表的定义和特点:

1. 线性表的定义:![image-20220815173354411](image-20220815173354411.png)![image-20220815173408870](image-20220815173408870.png)![image-20220815173619037](image-20220815173619037.png)![image-20220815175136741](image-20220815175136741.png)

2. 线性表的特点:![image-20220815173821542](image-20220815173821542.png)

   

#### 2).线性表的基本操作:

1. + 初始化:![image-20220815191828364](image-20220815191828364.png)
   + 销毁:![image-20220815191906662](image-20220815191906662.png)
   + 清除:![image-20220815191924630](image-20220815191924630.png)
   + 判断线性表是否为空:![image-20220815192001211](image-20220815192001211.png)
   + 线性表的长度:![image-20220815192034843](image-20220815192034843.png)
   + 取线性表中的第i个元素:![image-20220815192118040](image-20220815192118040.png)
   + 通过数值搜索下标:![image-20220815192252070](image-20220815192252070.png)
   + 获得当前元素的前驱:![image-20220815192332130](image-20220815192332130.png)
   + 获得当前元素的后继:![image-20220815192352280](image-20220815192352280.png)
   + 插入元素:![image-20220815192455562](image-20220815192455562.png)
   + 删除元素:![image-20220815192538563](image-20220815192538563.png)
   + 遍历:![image-20220815192555459](image-20220815192555459.png)

#### 3).线性表的存储结构:

##### 1).顺序存储结构:

###### 1.顺序存储结构的理论定义:



1. 顺序存储结构的定义:![image-20220816111425111](image-20220816111425111.png)注意:
   + 顺序存储结构所需的存储空间是连续的一片![image-20220816111600014](image-20220816111600014.png)
   + 线性表中的每个元素的存储位置可以通过==第一个数据元素的存储位置+每一个元素所占用的存储单元==得到![image-20220816111907445](image-20220816111907445.png)

2. ==故由上总结:每一个元素都可以通过类似等差数列的算法来计算,并且只需一次,所以时间复杂度为O(1)==

3. 虽然数组很像线性表,但是数组没有办法完成能够随意改变自身长度,故![image-20220816112756778](image-20220816112756778.png)

+ 举例:![image-20220816112939152](image-20220816112939152.png)

4. ==C语言实现顺序存储结构是通过数组动态分配做到的,而java则是在你创建的时候利用构造器来定义从而实现数组动态分配==

   C语言![image-20220816182429495](image-20220816182429495.png)![image-20220816182926547](image-20220816182926547.png)C++![image-20220816183119781](image-20220816183119781.png)Java![image-20220816182452856](image-20220816182452856.png)

###### 2.顺序存储结构实现的小结:

1. ==能够实现动态分配内存,也就是所谓的动态数组==
2. ==能够实现线性表的所有基本操作==![image-20220817211459997](image-20220817211459997.png)

###### 3.顺序存储结构的物理层:

1. 顺序表的物理位序和逻辑位序:![image-20220816183820918](image-20220816183820918.png)

###### 4.顺序表的实现:

1. 顺序表的预定义常量:![image-20220817211711058](image-20220817211711058.png)

2. 顺序表的初始化:![image-20220817211735827](image-20220817211735827.png)

3. 顺序表的销毁:![image-20220817211826690](image-20220817211826690.png)

4. 线性表的清空:![image-20220817211913449](image-20220817211913449.png)

5. 线性表的长度:![image-20220817211904045](image-20220817211904045.png)

6. 判断线性表L是否为空:![image-20220817211940535](image-20220817211940535.png)

7. 顺序表的取值:![image-20220817212005017](image-20220817212005017.png)

8. 顺序表的查找:![image-20220817212222020](image-20220817212222020.png)

   ==注意:这里的查找时间复杂度是根据查找的元素所决定的时间,需要引入平均查找长度这一概念==:![image-20220817220110960](image-20220817220110960.png)![image-20220817220543076](image-20220817220543076.png)==P代表查找成功的概率,C代表查找的元素==![image-20220817220248701](image-20220817220248701.png)

9. 顺序表的插入:![image-20220817221101854](image-20220817221101854.png)注意:==插入是只能插入在0-n+1的位置,n是最后元素的位置==![](image-20220817221437565.png)![image-20220817222722491](image-20220817222722491.png)

10. 顺序表的删除:

    ![image-20220817223506041](image-20220817223506041.png)![image-20220817223809600](image-20220817223809600.png)![image-20220817224241651](image-20220817224241651.png)

###### 顺序表总结:

1. 优缺点:![image-20220817224517599](image-20220817224517599.png)
2. 特点:![image-20220817224541839](image-20220817224541839.png)
3. 顺序表的时间和空间复杂度:![image-20220817224600338](image-20220817224600338.png)

##### 2).链式存储结构:

###### 1.链式存储结构的理论定义:

+ 顺序存储和链式存储区别:![image-20220818171023747](image-20220818171023747.png)

1. 链式存储结构:![image-20220818171439273](image-20220818171439273.png)

2. 单链式存储结构的理论定义:![image-20220818171230290](image-20220818171230290.png)

3. 单链表,双链表,循环链表的区别:![image-20220818171551684](image-20220818171551684.png)

4. 链表的各个元素:![image-20220818171718719](image-20220818171718719.png)注意:==头节点通常不会是首元结点(第一个元素所在位置)==
   + 带头节点和不带头节点:![image-20220818171955425](image-20220818171955425.png)
   + 空表的实现:![image-20220818172058110](image-20220818172058110.png)
   + ==带头结点的好处:==![image-20220818172610669](image-20220818172610669.png)

5. 链表的特点:![image-20220818172826336](image-20220818172826336.png)

   注意:

   1.顺序表是随机存取,链表是顺序存取![image-20220818172923154](image-20220818172923154.png)

   2.头节点不参与表长的计算

###### 2.单链表的实现:

1. 单链表的存储结构:![image-20220818181501089](image-20220818181501089.png)![image-20220818181739146](image-20220818181739146.png)

2. 单链表元素存储数据的建议操作:==如果有多个数据,可以把多个数据整合到一个模块,然后将这个模块再写入链表的数据域中==![image-20220818181948205](image-20220818181948205.png)

3. 单链表基本操作:

   + 初始化:![image-20220818205808147](image-20220818205808147.png)

   + 判断是否为空:![image-20220818205858112](image-20220818205858112.png)

   + ==销毁单链表:==![image-20220818210302210](image-20220818210302210.png)![image-20220818210315868](image-20220818210315868.png)注意:==销毁单链表是需要从头节点一点一点往后删除的,个人认为:原因在于链表元素的存储并不是按照一整个内存块存储,而是分开存储,所以即使直接删除了头节点,其他结点也会一直存在==

   + ==清空链表:==![image-20220818211158983](image-20220818211158983.png)![image-20220818211322250](image-20220818211322250.png)注意:==删除的关键是让链表变成空表==

     ==而空表的特征是只有头节点且没有数据==

     ==其次执行中由于需要在删除之前要能够继续获取下一个节点的数据,需要用两个指针来操作==

   + 单链表的表长(遍历):![image-20220818211805598](image-20220818211805598.png)![image-20220818211824580](image-20220818211824580.png)

   + 取单链表的第i个元素:![image-20220818212137899](image-20220818212137899.png)![image-20220818212154929](image-20220818212154929.png)![image-20220818212238300](image-20220818212238300.png)

   + 按值查找:![image-20220818212545945](image-20220818212545945.png)![image-20220818212554907](image-20220818212554907.png)![image-20220818212726127](image-20220818212726127.png)

   + ==插入元素:==![image-20220818213015108](image-20220818213015108.png)![image-20220818213118849](image-20220818213118849.png)![image-20220818214113307](image-20220818214113307.png)

     注意:插入的时候要考虑到非法操作,==插入算法中i的合理取值范围是1到n+1==

   + ==删除第i个节点:==![image-20220818214301656](image-20220818214301656.png)![image-20220818214354986](image-20220818214354986.png)![image-20220818214404427](image-20220818214404427.png)注意:删除这个节点的操作是链接跳过该节点且==释放该节点内存====而删除算法中i的合理取值范围为1到n==

4. 插入,删除,查找算法时间效率分析:![image-20220818215449793](image-20220818215449793.png)

###### 3.==单链表头插法建立:==

1. 原理:从==头节点的尾部==不断插入新元素![image-20220818231826488](image-20220818231826488.png)![image-20220818232004567](image-20220818232004567.png)

2. C实现源码:![image-20220818232049824](image-20220818232049824.png)

###### 4.==单链表尾插法建立:(之前使用的方法就是尾插法)==

1. 原理:==由头节点开始,一直添加新元素且向后递归==![image-20220818233437657](image-20220818233437657.png)
2. 实现:![image-20220818233544182](image-20220818233544182.png)

###### 5.循环链表:

1. 定义:![image-20220823193317067](image-20220823193317067.png)其中空表的定义:==头节点的指针指向头节点本身便是空表==

2. ==遍历操作:==![image-20220823193504202](image-20220823193504202.png)

   ==如果仍然是从头指针开始遍历,那么首尾的时间复杂度是==![image-20220823193825875](image-20220823193825875.png)==而如果是在尾指针开始遍历的话,那么首尾的时间复杂度会降低一个梯次:==![image-20220823193904364](image-20220823193904364.png)

3. ==两个循环链表的合并操作(四部):==![image-20220823201155117](image-20220823201155117.png)

   实现:![image-20220823201311207](image-20220823201311207.png)

###### 6.双向链表:

1. 双向链表的优点:![image-20220823201510511](image-20220823201510511.png)

2. 定义:![image-20220823201606950](image-20220823201606950.png)

3. ==双向链表的插入:==![image-20220823212320934](image-20220823212320934.png)关键在于==p节点的确定== 和==x的插入顺序==

   实现:![image-20220823212456616](image-20220823212456616.png)

4. ==双向链表的删除操作:==![image-20220823212759966](image-20220823212759966.png)![image-20220823212804911](image-20220823212804911.png)

###### 7.双向循环链表:

1. 定义(结构):![image-20220823201729089](image-20220823201729089.png)
2. 双向循环链表的特点(对称性):![image-20220823201939747](image-20220823201939747.png)

###### 8.单链表,循环链表,双向链表时间效率:

![image-20220823213904690](image-20220823213904690.png)

##### 3).顺序表和链表的比较:

###### 1.链式存储结构的优点和缺点![image-20220823215356731](image-20220823215356731.png)

1. 对于存储密度:![image-20220823215235657](image-20220823215235657.png)

###### 2.顺序表和链表的比较:

![image-20220823215527487](image-20220823215527487.png)

##### 4).线性表的应用:

###### 线性表的合并:![image-20220823215733034](image-20220823215733034.png)![image-20220823221259464](image-20220823221259464.png)![image-20220823221336673](image-20220823221336673.png)

###### 有序表的合并:

1. ==顺序表的合并:有序(其实就是双指针算法)==![image-20220823215745393](image-20220823215745393.png)![image-20220823221425675](image-20220823221425675.png)![image-20220823221716825](image-20220823221716825.png)![image-20220823221851746](image-20220823221851746.png)

2. 链表的合并:![image-20220825203221848](image-20220825203221848.png)注意:==![image-20220825203345216](image-20220825203345216.png)

   实践:![image-20220825210157630](image-20220825210157630.png)

###### 多项式运算:

==对待这种跨越有顺序且相对靠近的多项式,可以采用数组,下标记录幂次,元素记录常数项==

![image-20220825210421367](image-20220825210421367.png)![image-20220825210841185](image-20220825210841185.png)

###### 稀疏多项式运算:

![image-20220825211404074](image-20220825211404074.png)![image-20220825211626047](image-20220825211626047.png)

==由于稀疏多项式需要记录两个值,如果使用数组下标和元素的方式记录,会造成很大内存浪费,其次这个新数组的大小需要能够动态变化,故采用链表==![image-20220825211847461](image-20220825211847461.png)

![image-20220825212203970](image-20220825212203970.png)![image-20220825212301706](image-20220825212301706.png)![image-20220825212452471](image-20220825212452471.png)

##### 线性表的章节任务:

###### 图书管理系统:![image-20220829223908189](image-20220829223908189.png)![image-20220829223901611](image-20220829223901611.png)



#### 4).栈和队列:

##### 1).栈:

###### 栈的定义和特点:

1. 定义:![image-20220829225614599](image-20220829225614599.png)![image-20220829225927062](image-20220829225927062.png)栈的表示为了方便可视化,会把栈竖起来,栈底(表头)朝下,栈顶(表尾)朝上![image-20220829230255627](image-20220829230255627.png)

   注意:每次都是在栈顶入栈和出栈

   入栈:![image-20220829230406530](image-20220829230406530.png)

   出栈:

   ![image-20220829230420649](image-20220829230420649.png)

2. 特点:后进先出![image-20220829224326115](image-20220829224326115.png)

3. 使用背景:![image-20220829224352919](image-20220829224352919.png)

4. 栈与线性表的比较:![image-20220829231026356](image-20220829231026356.png)![image-20220829231035100](image-20220829231035100.png)

###### 栈的抽象数据类型:

1. 类型定义:![image-20220831230544415](image-20220831230544415.png)
1. 操作使用:(八大操作)![image-20220902231329893](image-20220902231329893.png)

###### ==顺序栈的表示和实现:==

1. 存储方式:![image-20220903154125895](image-20220903154125895.png)
1. 栈的使用:![image-20220903154554500](image-20220903154554500.png)![image-20220903154802908](image-20220903154802908.png)注意:栈内存满了再进栈导致溢出是上溢(==属于问题处理错误==),栈没有元素再出栈导致溢出时下溢(==属于问题处理结束==)

3. 顺序栈的实现:![](image-20220903155208255.png)
   + ==初始化:==![image-20220903155451090](image-20220903155451090.png)
   + 判断是否为空:![image-20220903193738550](image-20220903193738550.png)
   + 求元素数量:![image-20220903193824418](image-20220903193824418.png)
   + 清空栈:![image-20220903194345147](image-20220903194345147.png)
   + 销毁栈:![image-20220903223138459](image-20220903223138459.png)==注意:delete 是释放内存==
   + ==入栈==:![image-20220903223604859](image-20220903223604859.png)
   + ==出栈==:![image-20220903223756193](image-20220903223756193.png)

###### 链栈的表示和实现:

1. 链栈的表示:![image-20220909102323139](image-20220909102323139.png)

   注意:原先顺序栈的指针应该是由下指上,但是链表为了方便操作采用头插法

2. 链栈的初始化:![image-20220909102658653](image-20220909102658653.png)

3. 链栈是否为空:![image-20220909102719206](image-20220909102719206.png)

4. 链栈的入栈:![image-20220909102947317](image-20220909102947317.png)注意:==先让p指针的next指向s指针,在让s指针指向p指针==

5. 链栈的出栈:![image-20220909103129398](image-20220909103129398.png)

6. 取栈顶元素:![image-20220909104214626](image-20220909104214626.png)

###### 多个函数的嵌套调用:

1.嵌套的使用

![image-20220909110324713](image-20220909110324713.png)

可以发现从多个函数调用遵循==后调用的先返回(也就是先进后出)==,是栈的特点

2.嵌套的底层实现:

![image-20220909110902333](image-20220909110902333.png)



##### 2).队列:

###### 队列的定义和特点:

1. 定义:![image-20220829231159122](image-20220829231159122.png)
2. 特点:先进先出![image-20220829224507462](image-20220829224507462.png)![image-20220829225429742](image-20220829225429742.png)
3. 队列的相关概念:![image-20220829231307660](image-20220829231307660.png)

###### 栈的抽象数据类型定义:![image-20220909211629783](image-20220909211629783.png)

###### ==队列的顺序表示和实现:==

结构表示:![image-20220909211936140](image-20220909211936140.png)

###### ==顺序队列的两个问题:==

第一个问题:顺序队列的==假上溢==

顺序队列的正常入队和出队:![image-20220909212647972](image-20220909212647972.png)

可以看出上面有一个问题就是==如果当头指针在数组的最底层和尾指针在数组的最顶层,而下面的空间没有充分运用==,也就是==假上溢==![image-20220909212917525](image-20220909212917525.png)

对此问题有两个方法:

+ 解决根本问题的方法![image-20220909213105440](image-20220909213105440.png)

+ ==(实用)循环:==![image-20220909213206415](image-20220909213206415.png)

  此时便可以引用==模运算==!![image-20220909213921563](image-20220909213921563.png)

第二个问题:队列的队空和队满无法判断

![image-20220909214416078](image-20220909214416078.png)![image-20220909215014601](image-20220909215014601.png)

###### 循环队列的实现:

1. 循环队列的类型定义:![image-20220909215140083](image-20220909215140083.png)

2. 初始化:![image-20220909215257258](image-20220909215257258.png)
3. 求长度:![image-20220909215514497](image-20220909215514497.png)
4. ==入队==:![image-20220909215838735](image-20220909215838735.png)
5. ==出队==:![image-20220909220008815](image-20220909220008815.png)
6. 取队头元素:![image-20220909220115877](image-20220909220115877.png)

###### ==链式队列的定义==:

1. 链队列的类型定义:![image-20220910151843311](image-20220910151843311.png)

2. ==链队列的运算指针变化状况==:![image-20220910152051009](image-20220910152051009.png)

###### 队列的链式表达和实现:

1. 链队列初始化:![image-20220910153948056](image-20220910153948056.png)

   此处的!Q.front代表的Q.front空则退出

2. 链队列销毁:![image-20220910154237184](image-20220910154237184.png)

3. 入队:![image-20220910154736537](image-20220910154736537.png)注意:入队列是从队尾入

4. 出队:![image-20220910154906251](image-20220910154906251.png)!![image-20220910154937671](image-20220910154937671.png)

   注意:==需要考虑下一个出队的是尾节点的情况,故if(Q.rearp)就是考虑这个==

5. 取队头元素:![image-20220910155332333](image-20220910155332333.png)

##### 3).栈和队列:

1. ![image-20220829225545488](image-20220829225545488.png)

   

2. 栈和队列的引用案列:

   + 进制转换:![image-20220829231838642](image-20220829231838642.png)

   + 括号匹配的检验:![image-20220829232034951](image-20220829232034951.png)

     注意:先入栈的先匹配,后入栈的后匹配,

   + 表达式求值:![image-20220831225815311](image-20220831225815311.png)![image-20220831225909867](image-20220831225909867.png)![image-20220831230045708](image-20220831230045708.png)
   
   + 舞伴问题:![image-20220831230354499](image-20220831230354499.png)

#### 5).串,数组,广义表

##### 1.串

###### 串的定义:

![image-20220910155758460](image-20220910155758460.png)

###### 子串的定义:

![image-20220910160021322](image-20220910160021322.png)

###### 串的几个术语:

![image-20220911200035003](image-20220911200035003.png)

###### 串的案列引入:

![image-20220911200601900](image-20220911200601900.png)![image-20220911200607781](image-20220911200607781.png)

###### 串的类型定义:

![image-20220911200902850](image-20220911200902850.png)![image-20220911200926895](image-20220911200926895.png)

###### 顺序串的定义:

![image-20220911201524858](image-20220911201524858.png)

###### ==(块链结构串)==链式串的问题:

采用一个节点存储一个字符的方式的话,那么存储密度是1/5,存储密度太低![image-20220911202120488](image-20220911202120488.png)

故通常会采用一个节点存储一个字符块,这就是块链结构串

###### 块链结构的定义:

![image-20220911202228306](image-20220911202228306.png)

##### 2.数组

###### 数组的定义:

![image-20220918232411779](image-20220918232411779.png)

###### 二维数组:

二维数组的结构

![image-20220919211837065](image-20220919211837065.png)

二维数组的定义

![image-20220919223642679](image-20220919223642679.png)

###### n维数组

![image-20220919223726698](image-20220919223726698.png)

###### n维数组的抽象数据类型

![image-20220919232630864](image-20220919232630864.png)

如何理解:下列bi代表了有多少个维度

![image-20220919232903301](image-20220919232903301.png)

需要完成的基本操作:

![image-20220919233057514](image-20220919233057514.png)

###### 数组的顺序存储:

1. 数组的特点:

   ![image-20220919233312682](image-20220919233312682.png)

2. 一维数组的存储:查看元素的方法,a[i] = a + i * L;

   ![image-20220919233654432](image-20220919233654432.png)

3. 二维数组的存储:二维数组的存储是通过以行/列为主序进行存储![image-20220919233839225](image-20220919233839225.png)

4. 以行为主序的二维数组和以列为主序的二维数组:![image-20220919234155689](image-20220919234155689.png)

5. 二维数组的计算元素位置:![image-20220919234534051](image-20220919234534051.png)

6. 三维数组的存储方式:![image-20220919234635153](image-20220919234635153.png)![image-20220919234639744](image-20220919234639744.png)

7. n维数组的存储方式和存储位置计算:![image-20220919234847270](image-20220919234847270.png)

   

###### 特殊矩阵的压缩存储:

1. 原理:![image-20220920001137446](image-20220920001137446.png)

2. 定义:![image-20220920001353086](image-20220920001353086.png)

3. 对称矩阵:

   ![image-20220920001710486](image-20220920001710486.png)

   ![image-20220920001816686](image-20220920001816686.png)

4. 三角矩阵:

   ![image-20220920002046046](image-20220920002046046.png)

5. 对角矩阵:![image-20220920002110297](image-20220920002110297.png)![image-20220920002156866](image-20220920002156866.png)

6. 稀疏矩阵:![image-20220920002456535](image-20220920002456535.png)![image-20220920002555818](image-20220920002555818.png)![image-20220920111244246](image-20220920111244246.png)

###### ==稀疏矩阵的链式存储结构:十字链表==:

1. 十字链表的定义:![image-20220920111557471](image-20220920111557471.png)
2. 十字链表的形成:![image-20220920112204282](image-20220920112204282.png)注意:制作一个头节点元素数组,然后根据每一行或每一列通过指针索引一行或一列的指针

##### 3.广义表

###### 广义表的定义:

![image-20220920113518016](image-20220920113518016.png)

###### 注意一表尾一定是广义表

###### 注意二 长度是根据该表中的元素多少决定的,子表只算一个元素

###### 例子展示:

![image-20220920163828793](image-20220920163828793.png)

###### 广义表的特点(相对次序,长度,深度,共享,递归,多层次,):

![image-20220920165149891](image-20220920165149891.png)![image-20220920165258873](image-20220920165258873.png)

###### 广义表与线性表的区别:

![image-20220920165512276](image-20220920165512276.png)

###### 广义表的基本运算:

![image-20220920170020091](image-20220920170020091.png)

### 五,非线性结构:

#### 1).树和二叉树:

##### 1.树:

###### 树的定义:

![image-20220921000338016](image-20220921000338016.png)

###### 树的示意图:

![image-20220921000751469](image-20220921000751469.png)![image-20220921000903264](image-20220921000903264.png)

树有三种表达方式:嵌套集合,凹入表示,广义表

###### 树的基本术语:

![image-20220921214703353](image-20220921214703353.png)

结点:数据元素以及==指向子树的分支==

根结点:非空树中==无前驱==结点的结点

==结点的度==:结点拥有的==子树数==

==树的度==:树内各结点的==度的最大值==

###### 根据树的度可以分成两种类型

一种是度!=0分支结点非终端结点

一种是度=0(即叶子)是终端结点

![image-20220921215241847](image-20220921215241847.png)

###### 树的祖先,孩子,双亲,兄弟,堂兄弟:

![image-20220921215557022](image-20220921215557022.png)

###### 树的森林:

![image-20220921215806952](image-20220921215806952.png)

###### 线性结构和树结构的对比:

![image-20220921215850081](image-20220921215850081.png)

##### 2.二叉树:

###### 为什么要有二叉树:

对于普通树的算法实现非常困难且没有通用逻辑,且二叉树结构最简单![image-20220925174303088](image-20220925174303088.png)

###### 二叉树的定义:

![image-20220925174404401](image-20220925174404401.png)

###### ==注意:二叉树不是树的特殊情况,因为要区分左右子树的次序==

![image-20220925174515374](image-20220925174515374.png)

###### 二叉树的五种形态和树的两种形态:

![image-20220925181028375](image-20220925181028375.png)![image-20220925181316865](image-20220925181316865.png)

###### 二叉树的抽象数据类型定义:

![image-20220925184519989](image-20220925184519989.png)

![image-20220925184701727](image-20220925184701727.png)

###### 二叉树的性质:

性质1:二叉树的第i层至多有2的i-1个结点(i >=1),且最少有1个结点:

![image-20220925185126279](image-20220925185126279.png)

性质2:深度为k的二叉树==至多==有2的k-1个结点(k>=1):即总共有2的k-1个结点,==最少==也得有k层结点![image-20220925185422294](image-20220925185422294.png)

性质3:对任何一棵二叉树T,如果其叶子树为n0,度为2的结点数为n2,则n0=n2+1![image-20220925205558322](image-20220925205558322.png)

n2指的是能有两个结点的根数量,n1指的是只有一个的数量

###### 二叉树的存储结构:

1. 顺序存储:![image-20220925221806315](image-20220925221806315.png)

2. 顺序存储的类型定义:![image-20220925221904769](image-20220925221904769.png)

3. 顺序存储的实现:![image-20220925225924077](image-20220925225924077.png)

   注意:二叉树的顺序存储是在一些情况下是不能直接存储的,比如下面这个例子![image-20220925230132677](image-20220925230132677.png)

   这个例子呈现的问题是如果5和6号存储的是f和g,那么该二叉树的结构就成了完全二叉树,因为为了描述二叉树双亲和孩子的关系![image-20220925230533902](image-20220925230533902.png)

4. 二叉树的顺序存储缺点:如果是最坏情况很浪费内存空间![image-20220925230949014](image-20220925230949014.png)

   故只有在最好和较好情况才会使用这个

5. 链式存储的图示:![image-20220925231501268](image-20220925231501268.png)

6. 链式存储的定义:![image-20220925233545378](image-20220925233545378.png)

7. 链式存储中有n个结点的二叉链表,会有n+1个空指针域:![image-20220925233001370](image-20220925233001370.png)

   链域是指存储链表元素指针的指针,n-1代表除了根节点之外的所有结点

###### 三叉链表:

![image-20220925233926128](image-20220925233926128.png)

注意:只有根节点的双亲为空,其他肯定有双亲结点

##### 3.满二叉树:

###### 学习的原因:

![image-20220925211307178](image-20220925211307178.png)

###### 定义:

![image-20220925211509610](image-20220925211509610.png)

例子:![image-20220925211646833](image-20220925211646833.png)



##### 4.完全二叉树(满二叉树是特殊的完全二叉树):

###### 定义:![image-20220925211841793](image-20220925211841793.png)

能够跟满二叉树的编号的结点一一对应,故每一个结点都应该一一对应

![image-20220925215653818](image-20220925215653818.png)

###### 特点:

![image-20220925215854755](image-20220925215854755.png)

###### 性质:

性质1(结点树n和深度k的关系):具有n个结点的完全二叉树的深度为[log2n] + 1

![image-20220925220057248](image-20220925220057248.png)

如何得出:

![image-20220925220209075](image-20220925220209075.png)

性质2(双亲结点编号和孩子结点编号):![image-20220925220722327](image-20220925220722327.png)

##### 5.二叉树的递归遍历:

###### 二叉树为什么要遍历:

![image-20220927173853594](image-20220927173853594.png)

###### 遍历的方法:

![image-20220927174027067](image-20220927174027067.png)

###### 遍历有三种情况:

![image-20220927174148422](image-20220927174148422.png)

###### 遍历二叉树算法描述:

![image-20220927174435594](image-20220927174435594.png)

###### 先序遍历二叉树的例子:

![image-20220927174831084](image-20220927174831084.png)

###### 中序遍历二叉树的例子:

![image-20220927175207492](image-20220927175207492.png)

###### 后序遍历二叉树的例子:

![image-20220927175509586](image-20220927175509586.png)

###### 

###### 用二叉树表示算数表达式:

![image-20220927175805671](image-20220927175805671.png)

###### 根据遍历序列确定二叉树需要==中序序列==和==其他两个序列任意一个==:(有点类似于二分法的思想)

![image-20220927180147691](image-20220927180147691.png)

根据通过先序或后序找到的根,找出中序中根的位置进行分开

![image-20220927180853284](image-20220927180853284.png)![image-20220927181120944](image-20220927181120944.png)

###### ==用递归实现二叉树先序遍历算法==:

![image-20220927182138744](image-20220927182138744.png)

###### 用递归实现二叉树中序遍历算法:

![image-20220928223321178](image-20220928223321178.png)

###### 用递归实现二叉树后序遍历算法:

![image-20220928223625653](image-20220928223625653.png)

###### 三种算法的总结:

![image-20220928223826481](image-20220928223826481.png)

实际上三种算法的访问路径完全相同,都是沿虚线路径走,只是操作的顺序不同![image-20220928224019214](image-20220928224019214.png)

##### 6.二叉树的非递归遍历:

###### 中序遍历非递归算法思想:

![image-20220928224437003](image-20220928224437003.png)

###### 中序遍历非递归算法实现:

![image-20220928224931821](image-20220928224931821.png)

##### 7.二叉树的层次遍历:

###### 算法思想:(这里是用队列,其实可以用栈实现,可以思考一下如何实现)

利用队列,将根节点出队列,有左右孩子的入队列,持续下去![image-20220928225409606](image-20220928225409606.png)

###### 实现:(结构:数组,左子树,右子树)

![image-20220930161038858](image-20220930161038858.png)

##### 8.二叉树的建立:

###### 先序遍历序列建立算法:

![image-20220930161651223](image-20220930161651223.png)注意:==仅仅靠先序序列的顺序来创建二叉树不是唯一的,所以需要通过补充空结点来确定,故空结点需要用一个字符来表示,如‘#’,’ ’==

###### 实现:

![image-20220930162146276](image-20220930162146276.png)





## 算法 

### 一,算法的概念:

#### 1).算法的定义:![image-20220815160224283](image-20220815160224283.png)

#### 2).算法的描述:

1. 自然语言(英语,中文)
2. 传统流程图:![image-20220815160338157](image-20220815160338157.png)
3. NS流程图:![image-20220815160354186](image-20220815160354186.png)
4. 伪代码(类语言):类C语言
5. 程序代码

#### 3).程序和算法的关系:

![image-20220815160509698](image-20220815160509698.png)

#### 4).算法的五大特性:![image-20220815160632629](image-20220815160632629.png)

#### 5).算法设计的要求:

![image-20220815160749315](image-20220815160749315.png)![image-20220815160756104](image-20220815160756104.png)![image-20220815160835835](image-20220815160835835.png)![image-20220815160920284](image-20220815160920284.png)

### 二,算法分析:

#### 1).算法的两个效率:

+ 算法时间效率:(多数会采用事前分析,事前分析不用考虑外界的干扰)![image-20220815161232565](image-20220815161232565.png)![image-20220815161341618](image-20220815161341618.png)![image-20220815161510180](image-20220815161510180.png)

#### 2).算法的时间复杂度:

##### 1).算法时间复杂度的渐进表示法:

1. O表示的是数量级![image-20220815161738812](image-20220815161738812.png)<img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220814162831356.png" alt="image-20220814162831356" style="zoom:200%;" />

2. 大O的渐进表示法(大O的都是估算)![image-20220814163356785](image-20220814163356785.png)

3. 对于两个未知值M,N的时间复杂度计算

   注意:如果没有说明M,N的大小关系,那么就是O(M+N)

   ![image-20220814163956571](image-20220814163956571.png)

4. 对于O(1)的理解:![image-20220814164156645](image-20220814164156645.png)

##### 2).算法时间复杂度的计算:

1. + ![image-20220815162625804](image-20220815162625804.png)
   + 基本语句重复执行的次数,该基本语句是:![image-20220815162612719](image-20220815162612719.png)
   + 问题规模n是来描述数据量的一个变量:![image-20220815162725924](image-20220815162725924.png)

2. 计算的基本方法:第一步:找出执行次数最多的那个语句(通常是嵌套程度最深的)![image-20220815164352304](image-20220815164352304.png)![image-20220815164611770](image-20220815164611770.png)

3. 注意:对于对数集:![image-20220815170241678](image-20220815170241678.png)

##### 3).时间复杂度对复杂情况的表现:

1. 有三种情况![image-20220815170857612](image-20220815170857612.png)![image-20220814164540312](image-20220814164540312.png)

2. 对于这种复杂算法的通常取向:最坏情况,但如果最坏情况很少出现,那么就会选用平均情况(比如说希尔排序)![image-20220814164742307](image-20220814164742307.png)

3. 对于多种未知值的时间复杂度的两个法则:![image-20220815171032304](image-20220815171032304.png)

4. 不同阶的数量级:![image-20220815171158927](image-20220815171158927.png)

#### 3).算法的空间复杂度:

##### 1).渐进空间复杂度

1. 空间复杂度定义:![image-20220815171519218](image-20220815171519218.png)

2. 主要是看算法所要使用的辅助空间:![image-20220815172243284](image-20220815172243284.png)如上就是当辅助空间是由一个单位时那么就一个,如果是一个根据n变化的数组时 那么就是O(n)

#### 4).算法设计总结:![image-20220815172536974](image-20220815172536974.png)

### 三,具体算法:

#### 1).递归:

##### 递归的定义:![image-20220909105025006](image-20220909105025006.png)

##### 递归的使用背景:![image-20220909105350104](image-20220909105350104.png)

###### 递归定义的数学函数:![image-20220909105143603](image-20220909105143603.png)

###### 具有递归特性的数据结构:![image-20220909105233049](image-20220909105233049.png)

##### 递归的调用规则:

1. 递归的调用过程:![image-20220909105704310](image-20220909105704310.png)

2. 递归的优缺点:![image-20220909211318784](image-20220909211318784.png)

+ 解决缺点的方法:
+ 1. ![image-20220909211359642](image-20220909211359642.png)
  2. ![image-20220909211409774](image-20220909211409774.png)

#### 2).串的模式匹配算法:

##### 模式匹配算法的概述:

![image-20220911202706360](image-20220911202706360.png)

##### 穷举法:

![image-20220911202808330](image-20220911202808330.png)

##### ==KMP算法==:

###### KMP算法的设计思想:

解决穷举法中不必要的回溯,故在此算法中是不会对txt进行回溯![image-20220911210154816](image-20220911210154816.png)

==有限状态自动机(就是KMP中的next[j]记录的值)==:![image-20220911210243991](image-20220911210243991.png)

注意:==从头开始的k-1个元素和j前面的k-1个元素==指的是==子串中第j个元素前面子串的前缀和后缀==

前缀:”abcd”串中的a,ab,abc

后缀:”abcd”串中的d,cd,bcd

注意:前缀后缀都是指真集

==next[j]算法举例:算法(最大公共前后缀+1=k（主串的当前字符）)==:![image-20220911212333301](image-20220911212333301.png)

###### KMP实现:

![image-20220911213447268](image-20220911213447268.png)![image-20220912173614277](image-20220912173614277.png)

```java
    public int[] getNext(char[] arr){
        int length = arr.length;
        int[] next = new int[length + 1];
        int j = next[1] = 0;
        int i = 1;
        while(i < length){
            if(j == 0 || arr[i - 1] == arr[j - 1]){
                ++i;++j;
                next[i] = j;
            }else j = next[j];
        }
        return next;
    }
```

注意:arr[i - 1]和arr[j - 1]是为了匹对

###### KMP中对特殊情况next函数的改进:

根据上面的next数组会出现一个情况:![image-20220911214000184](image-20220911214000184.png)

如上:实际上此时的子串回溯是为了找到b,但是可以看出前面都是一样的,没有必要再往前找了

故引入nextval来解决![image-20220911214652398](image-20220911214652398.png)

总结规律:

![image-20220911222411071](image-20220911222411071.png)



